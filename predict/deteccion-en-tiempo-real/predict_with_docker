#!/usr/bin/env bash
set -e

# Script para ejecutar YOLO con best.pt en Docker usando imagen Ultralytics
# Compatible con Jetson Jetpack 6

# Configuración por defecto
IMG="ultralytics/ultralytics:latest-jetson-jetpack6"
MODEL_PATH="weights/merged/best.pt"
VIDEO_DEVICE="video0"  # Por defecto video0
IMG_SIZE=640  # Resolución de imagen (por defecto 640, más rápido que 720p)

# Función de ayuda
show_help() {
    echo "Uso: $0 [OPCIONES]"
    echo ""
    echo "Opciones:"
    echo "  --video DEVICE    Especifica el dispositivo de video (por defecto: video0)"
    echo "                    Ejemplos: --video video0, --video video1, --video 0"
    echo "  --imgsz SIZE      Especifica el tamaño de imagen (por defecto: 640)"
    echo "                    Valores comunes: 320, 480, 640, 1280"
    echo "                    Menor = más rápido pero menos detalle"
    echo "  -h, --help        Muestra esta ayuda"
    echo ""
    echo "Ejemplos:"
    echo "  $0                    # Usa video0, resolución 640 (por defecto)"
    echo "  $0 --video video1     # Usa video1"
    echo "  $0 --imgsz 480         # Usa resolución 480 (más rápido)"
    echo "  $0 --video 1 --imgsz 320  # Usa video1 con resolución 320"
}

# Parsear argumentos
while [[ $# -gt 0 ]]; do
    case $1 in
        --video)
            VIDEO_DEVICE="$2"
            shift 2
            ;;
        --imgsz)
            IMG_SIZE="$2"
            shift 2
            ;;
        -h|--help)
            show_help
            exit 0
            ;;
        *)
            echo "❌ Opción desconocida: $1"
            echo ""
            show_help
            exit 1
            ;;
    esac
done

# Normalizar el dispositivo de video
# Si es solo un número, convertir a video{N}
if [[ "$VIDEO_DEVICE" =~ ^[0-9]+$ ]]; then
    VIDEO_SOURCE="$VIDEO_DEVICE"
    VIDEO_DEVICE="video$VIDEO_DEVICE"
else
    # Si ya tiene "video" al inicio, extraer el número para source
    if [[ "$VIDEO_DEVICE" =~ ^video([0-9]+)$ ]]; then
        VIDEO_SOURCE="${BASH_REMATCH[1]}"
    else
        # Si no tiene formato estándar, usar como está
        VIDEO_SOURCE="$VIDEO_DEVICE"
    fi
fi

# Obtener directorio del script y navegar al directorio raíz del proyecto
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(cd "$SCRIPT_DIR/../.." && pwd)"
MODEL_FULL_PATH="$SCRIPT_DIR/$MODEL_PATH"

# Verificar que el modelo existe
if [ ! -f "$MODEL_FULL_PATH" ]; then
    echo "❌ Error: No se encontró el modelo en $MODEL_FULL_PATH"
    exit 1
fi

# Preparar X11 y descargar imagen
xhost +local:docker
sudo docker pull "$IMG"

# Ejecutar contenedor con la misma estructura simple que test.sh
sudo docker run -it --rm --ipc=host \
  --runtime=nvidia \
  --gpus all \
  -v "$PROJECT_ROOT:/workspace" \
  --device=/dev/$VIDEO_DEVICE:/dev/$VIDEO_DEVICE \
  -e DISPLAY=$DISPLAY \
  -v /tmp/.X11-unix:/tmp/.X11-unix \
  -w /workspace/predict/deteccion-en-tiempo-real \
  "$IMG" bash -c "\
    apt-get update && apt-get install -y \
      libqt5x11extras5 \
      libxcb-icccm4 \
      libxcb-image0 \
      libxcb-keysyms1 \
      libxcb-randr0 \
      libxcb-render-util0 \
      libxcb-xinerama0 \
      libxkbcommon-x11-0 \
      x11-xserver-utils \
      python3-opencv && \
    MODEL_ENGINE_PATH=\$(echo '$MODEL_PATH' | sed 's/\.pt$/.engine/') && \
    test -f \"\$MODEL_ENGINE_PATH\" || yolo export model='$MODEL_PATH' format=engine && \
    yolo predict model=\"\$MODEL_ENGINE_PATH\" source='$VIDEO_SOURCE' imgsz='$IMG_SIZE' show=True"

echo "✅ Finalizado"
